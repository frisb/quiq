{"version":3,"file":"persistent.js","sourceRoot":"","sources":["../../../src/server/transport/persistent.ts"],"names":[],"mappings":";;;AAAA,qCAAkC;AAClC,iCAAwC;AACxC,mCAAiC;AAGjC,MAAM,MAAM,GAAG,IAAI,iBAAO,CAAC,sBAAsB,CAAC,CAAC;AAEnD,MAAa,mBAAoB,SAAQ,oBAAa;IAKpD,YAAY,OAAoC;QAC9C,KAAK,CAAC,OAAO,CAAC,CAAC;QAJV,qBAAgB,GAAiB,IAAI,CAAC;QACtC,kBAAa,GAAY,IAAI,CAAC;QAKnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC,CAAC;QAEjD,IAAI;aACD,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;YACpB,IAAI,IAAI,CAAC,gBAAgB,KAAK,IAAI,EAAE;gBAClC,aAAa,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBACrC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;aAC9B;QACH,CAAC,CAAC;aACD,EAAE,CAAC,cAAc,EAAE,GAAG,EAAE;YACvB,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa;gBAC9C,IAAI,CAAC,SAAS,EAAE,CAAC;QACrB,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,UAAU,CAAC,aAAuB;QACvC,IAAI,OAAM,CAAC,aAAa,CAAC,KAAK,WAAW,IAAI,aAAa,KAAK,KAAK;YAClE,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;QAE7B,KAAK,CAAC,UAAU,EAAE,CAAC;IACrB,CAAC;IAEK,IAAI,CAAC,OAAY;QACrB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;IACtC,CAAC;IAEO,SAAS;QACf,IAAI,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC;QAE7B,IAAI,aAAa,GAAG,CAAC,IAAI,IAAI,CAAC,gBAAgB,KAAK,IAAI,EAAE;YACvD,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC,GAAG,EAAE;gBACvC,IAAI,IAAI,CAAC,KAAK,KAAK,aAAK,CAAC,IAAI,EAAE;oBAC7B,MAAM,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;oBAClE,IAAI,CAAC,OAAO,EAAE,CAAC;iBAChB;YACH,CAAC,EAAE,aAAa,CAAC,CAAC;SACnB;IACH,CAAC;CACF;AA9CD,kDA8CC","sourcesContent":["import { Writeln } from 'writeln';\nimport { BaseTransport }  from './base';\nimport { State }  from './state';\nimport { IPersistentTransportOptions } from '../contracts';\n\nconst logger = new Writeln('Persistent Transport');\n\nexport class PersistentTransport extends BaseTransport {\n\tprivate retryInterval: number;\n\tprivate reconnectTimerID: NodeJS.Timer = null;\n\tprivate mustReconnect: boolean = true;\n\n  constructor(options: IPersistentTransportOptions) {\n    super(options);\n\n    this.retryInterval = options.retryInterval || -1;\n\n    this\n      .on('connected', () => {\n        if (this.reconnectTimerID !== null) {\n          clearInterval(this.reconnectTimerID);\n          this.reconnectTimerID = null;\n        }\n      })\n      .on('disconnected', () => {\n        if (this.retryInterval > 0 && this.mustReconnect)\n          this.reconnect();\n      });\n  }\n\n  public disconnect(mustReconnect?: boolean) {\n    if (typeof(mustReconnect) !== 'undefined' && mustReconnect === false)\n      this.mustReconnect = false;\n\n    super.disconnect();\n  }\n\n\tpublic send(message: any) {\n    super.send(JSON.stringify(message));\n  }\n\n  private reconnect() {\n    let { retryInterval } = this;\n\n    if (retryInterval > 0 && this.reconnectTimerID === null) {\n      this.reconnectTimerID = setInterval(() => {\n        if (this.state !== State.OPEN) {\n          logger.info(`retrying in ${Math.floor(retryInterval / 1000)}sec`);\n          this.connect();\n        }\n      }, retryInterval);\n    }\n  }\n}\n"]}