{"version":3,"file":"server.js","sourceRoot":"","sources":["../../../../src/server/socket/abstract/server.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebSocket from 'ws';\nimport { IncomingMessage } from 'http';\nimport { process } from 'ipaddr.js';\nimport { Writeln } from 'writeln';\nimport { IWSServerOptions, IWSSocket, ISession, IIncomingMessage } from '../contracts';\nimport { Tokenizer, NoTokenError } from '../../tokenizer';\nimport { AbstractClient } from './client';\nimport { AbstractGateway } from './gateway';\nimport { AbstractSession } from './session';\n\nconst logger = new Writeln('WebSocket Server');\n\ninterface IX { origin: string; secure: boolean; req: IncomingMessage }\ntype T = (res: boolean, code?: number, message?: string) => void;\n\nexport abstract class AbstractServer<TSession extends ISession, TClient extends AbstractClient<TSession>, TGateway extends AbstractGateway<TSession>> {\n\n\t/**\n\t * Get session\n\t * @param {string} id\n\t */\n\tpublic static getSession<S extends AbstractSession<S, C, G>, C extends AbstractClient<S>, G extends AbstractGateway<S>>(id: string): S {\n\t\treturn <S> AbstractSession.get<S, C, G>(id);\n\t}\n\n\tprivate tokenizer: Tokenizer = null;\n\n\tpublic constructor(options: IWSServerOptions) {\n\t\tconst wsServer = new WebSocket.Server(Object.assign(options, { verifyClient: options.verifyClient || this.verifyClient.bind(this) }));\n\n\t\tconst { signing } = options;\n\n\t\tif (signing)\n\t\t\tthis.tokenizer = new Tokenizer(signing);\n\n\t\twsServer.on('connection', (socket: IWSSocket, request: IIncomingMessage): void => {\n\t\t\tconst { protocol } = socket;\n\t\t\tconst { tokenData } = request;\n\n\t\t\tconst SessionType = this.getSessionClass(protocol);\n\t\t\tconst ClientType = this.getClientClass(protocol);\n\t\t\tconst GatewayType = this.getGatewayClass(protocol);\n\n\t\t\tlet session: TSession;\n\t\t\tconst client = new ClientType(socket, request);\n\n\t\t\tif (tokenData && tokenData.sessionID) {\n\t\t\t\tsession = <any> AbstractServer.getSession(tokenData.sessionID);\n\t\t\t}\n\n\t\t\tif (session) {\n\t\t\t\tlogger.debug(`Resuming existing session ${ session.ID }`);\n\n\t\t\t\tsession.client = client;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet gateway: TGateway;\n\n\t\t\t\tif (GatewayType)\n\t\t\t\t\tgateway = new GatewayType();\n\n\t\t\t\tsession = new SessionType(client, gateway);\n\n\t\t\t\tlogger.debug(`Creating new session ${ session.ID } with client${ gateway ? ' and gateway' : '' }`);\n\n\t\t\t\tsession\n\t\t\t\t\t// .on('registered', function () {\n\t\t\t\t\t// \t// add to B: dict\n\t\t\t\t\t// })\n\t\t\t\t\t.on('end', function (code: number, reason: string) {\n\t\t\t\t\t\t// remove from dictionary\n\t\t\t\t\t\t// session = null;\n\n\t\t\t\t\t\t// abortHandshake(socket, code, reason);\n\t\t\t\t\t\tclient.close();\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected useTokens(protocol: string): boolean {\n\t\treturn this.tokenizer !== null;\n\t}\n\n\tprotected abstract getSessionClass(protocol: string): { new(client: TClient, gateway: TGateway): TSession };\n\n\tprotected abstract getClientClass(protocol: string): { new(socket: IWSSocket, request: IncomingMessage): TClient };\n\n\tprotected abstract getGatewayClass(protocol: string): { new(): TGateway };\n\n\tprivate async verifyClient(info: IX, callback: T) {\n\t\tconst req = info.req as IIncomingMessage;\n\t\tconst { url, headers, socket: { remoteAddress, localPort } } = req;\n\n\t\tlet ipv4 = process(remoteAddress).toString();\n\t\tlet channelHost = <string> headers.host;\n\n\t\tif (channelHost.indexOf(':') < 0)\n\t\t\tchannelHost += `:${ localPort }`;\n\n\t\tif (ipv4 === '::1')\n\t\t\tipv4 = '127.0.0.1';\n\n\t\tif (this.useTokens(headers['sec-websocket-protocol'] as string)) {\n\t\t\t// try {\n\t\t\t\tif (url.length > 20) {\n\t\t\t\t\tconst token = url.substr(1);\n\n\t\t\t\t\treq.tokenData = await this.tokenizer.unwrap(ipv4, channelHost, token);\n\t\t\t\t\treq.ipv4 = ipv4;\n\n\t\t\t\t\tcallback(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoTokenError();\n\t\t\t\t}\n\t\t\t// }\n\t\t\t// catch (err) {\n\t\t\t// \tcallback(false, err.httpCode, err.message);\n\t\t\t// }\n\t\t}\n\t\telse {\n\t\t\tcallback(true);\n\t\t}\n\t}\n}\n"]}