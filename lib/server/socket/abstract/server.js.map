{"version":3,"file":"server.js","sourceRoot":"","sources":["../../../../src/server/socket/abstract/server.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebSocket from 'ws';\nimport { IncomingMessage, STATUS_CODES } from 'http';\nimport { Socket } from 'net';\nimport { process } from 'ipaddr.js';\nimport { Writeln } from 'writeln';\nimport { IWSServerOptions, IWSSocket, ISession } from '../contracts';\nimport { Tokenizer, NoTokenError } from '../../tokenizer';\nimport { AbstractClient } from './client';\nimport { AbstractGateway } from './gateway';\nimport { AbstractSession } from './session';\n\nconst logger = new Writeln('WebSocket Server');\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection (socket: Socket, code: number, message: string, err?: Error) {\n\tif (socket.writable) {\n\t\tmessage = message || STATUS_CODES[code];\n\t\tsocket.write(\n\t\t\t`HTTP/1.1 ${ code } ${ STATUS_CODES[code] }\\r\\n` +\n\t\t\t'Connection: close\\r\\n' +\n\t\t\t'Content-type: text/html\\r\\n' +\n\t\t\t`Content-Length: ${ Buffer.byteLength(message) }\\r\\n` +\n\t\t\t'\\r\\n' +\n\t\t\tmessage\n\t\t);\n\t}\n\n\tsocket.destroy();\n\n\tlogger.error(`${ code } ${ message }`, err);\n}\n\n// export function protocol<TClient extends Client<ISession>>(test: string) {\n// \treturn function<TServer extends Server<ISession, TClient, Gateway<ISession>>>(target: TServer) {\n//     // save a reference to the original constructor\n// \t\tconst original = target;\n\n// \t\t// a utility function to generate instances of a class\n// \t\tfunction construct(constructor: TServer, args: any) {\n// \t\t\tfunction c(): void {\n// \t\t\t\treturn (<any> constructor).apply(this, args);\n// \t\t\t}\n\n// \t\t\tc.prototype = (<any> constructor).prototype;\n\n// \t\t\treturn new (<any> c)();\n// \t\t}\n\n// \t\t// the new constructor behaviour\n// \t\tfunction f(...args: Array<any>) {\n// \t\t\tconsole.log(\"New: \" + (<any> original).name);\n// \t\t\treturn construct(original, args);\n// \t\t}\n\n// \t\t// copy prototype so intanceof operator still works\n// \t\tf.prototype = (<any> original).prototype;\n\n// \t\t// return new constructor (will override original)\n// \t\treturn f;\n// \t};\n// }\n\nexport abstract class AbstractServer<TSession extends ISession, TClient extends AbstractClient<TSession>, TGateway extends AbstractGateway<TSession>>\nextends WebSocket.Server {\n\n\t/**\n\t * Get session\n\t * @param {string} id\n\t */\n\tpublic static getSession<S extends AbstractSession<S, C, G>, C extends AbstractClient<S>, G extends AbstractGateway<S>>(id: string): S {\n\t\treturn <S> AbstractSession.get<S, C, G>(id);\n\t}\n\n\tprivate tokenizer: Tokenizer = null;\n\n\tpublic constructor(options: IWSServerOptions) {\n\t\tsuper(options);\n\n\t\tlet { signing } = options;\n\n\t\tif (signing)\n\t\t\tthis.tokenizer = new Tokenizer(signing);\n\n\t\tthis.on('connection', (...args: any[]): void => {\n\t\t\tlet socket: IWSSocket = args[0];\n\t\t\tlet { protocol, tokenData } = socket;\n\n\t\t\tlet SessionType = this.getSessionClass(protocol);\n\t\t\tlet ClientType = this.getClientClass(protocol);\n\t\t\tlet GatewayType = this.getGatewayClass(protocol);\n\n\t\t\tlet session: TSession;\n\t\t\tlet client = new ClientType(socket);\n\n\t\t\tif (tokenData && tokenData.sessionID) {\n\t\t\t\tsession = <any> AbstractServer.getSession(tokenData.sessionID);\n\t\t\t}\n\n\t\t\tif (session) {\n\t\t\t\tlogger.debug(`Resuming existing session ${ session.ID }`);\n\n\t\t\t\tsession.client = client;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet gateway: TGateway;\n\n\t\t\t\tif (GatewayType)\n\t\t\t\t\tgateway = new GatewayType();\n\n\t\t\t\tsession = new SessionType(client, gateway);\n\n\t\t\t\tlogger.debug(`Creating new session ${ session.ID } with client${ gateway ? ' and gateway' : '' }`);\n\n\t\t\t\tsession\n\t\t\t\t\t// .on('registered', function () {\n\t\t\t\t\t// \t// add to B: dict\n\t\t\t\t\t// })\n\t\t\t\t\t.on('end', function (code: number, reason: string) {\n\t\t\t\t\t\t// remove from dictionary\n\t\t\t\t\t\t// session = null;\n\n\t\t\t\t\t\t// abortConnection(socket, code, reason);\n\t\t\t\t\t\tclient.close();\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async handleUpgrade(request: IncomingMessage, socket: Socket, upgradeHead: Buffer, callback: (cws: WebSocket) => void) {\n\t\tlet clientSocket = await this.baseUpgrade(request, socket, upgradeHead);\n\n\t\tlet { url } = request;\n\t\tlet { remoteAddress, localPort } = socket;\n\t\tlet ipv4 = process(remoteAddress).toString();\n\t\tlet channelHost = clientSocket.upgradeReq.headers.host;\n\n\t\tif (channelHost.indexOf(':') < 0)\n\t\t\tchannelHost += `:${ localPort }`;\n\n\t\tif (ipv4 === '::1')\n\t\t\tipv4 = '127.0.0.1';\n\n\t\tif (this.useTokens(clientSocket.protocol)) {\n\t\t\ttry {\n\t\t\t\tif (url.length > 20) {\n\t\t\t\t\tlet token = url.substr(1);\n\t\t\t\t\tlet tokenData = await this.tokenizer.unwrap(ipv4, channelHost, token);\n\n\t\t\t\t\tclientSocket.tokenData = tokenData;\n\t\t\t\t\tclientSocket.ipv4 = ipv4;\n\n\t\t\t\t\tcallback(clientSocket);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoTokenError();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tabortConnection(socket, err.httpCode, err.message, err);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcallback(clientSocket);\n\t\t}\n\t}\n\n\tprotected useTokens(protocol: string): boolean {\n\t\treturn this.tokenizer !== null;\n\t}\n\n\tprotected abstract getSessionClass(protocol: string): { new(client: TClient, gateway: TGateway): TSession };\n\n\tprotected abstract getClientClass(protocol: string): { new(socket: IWSSocket): TClient };\n\n\tprotected abstract getGatewayClass(protocol: string): { new(): TGateway };\n\n\tprivate baseUpgrade(request: IncomingMessage, socket: Socket, upgradeHead: Buffer): Promise<any> {\n\t\treturn new Promise((resolve) => super.handleUpgrade(request, socket, upgradeHead, resolve));\n\t}\n}\n"]}