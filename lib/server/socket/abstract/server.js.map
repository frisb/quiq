{"version":3,"file":"server.js","sourceRoot":"","sources":["../../../../src/server/socket/abstract/server.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebSocket from 'ws';\nimport { IncomingMessage, STATUS_CODES } from 'http';\nimport { Socket } from 'net';\nimport { process } from 'ipaddr.js';\nimport { Writeln } from 'writeln';\nimport { IWSServerOptions, IWSSocket, ISession } from '../contracts';\nimport { Tokenizer, NoTokenError } from '../../tokenizer';\nimport { AbstractClient } from './client';\nimport { AbstractGateway } from './gateway';\nimport { AbstractSession } from './session';\n\nconst logger = new Writeln('WebSocket Server');\n\n// /**\n//  * Close the connection when preconditions are not fulfilled.\n//  *\n//  * @param {net.Socket} socket The socket of the upgrade request\n//  * @param {Number} code The HTTP response status code\n//  * @param {String} [message] The HTTP response body\n//  * @private\n//  */\n// function abortConnection (socket: Socket, code: number, message: string, err?: Error) {\n// \tif (socket.writable) {\n// \t\tmessage = message || STATUS_CODES[code];\n// \t\tsocket.write(\n// \t\t\t`HTTP/1.1 ${ code } ${ STATUS_CODES[code] }\\r\\n` +\n// \t\t\t'Connection: close\\r\\n' +\n// \t\t\t'Content-type: text/html\\r\\n' +\n// \t\t\t`Content-Length: ${ Buffer.byteLength(message) }\\r\\n` +\n// \t\t\t'\\r\\n' +\n// \t\t\tmessage\n// \t\t);\n// \t}\n//\n// \tsocket.destroy();\n//\n// \tlogger.error(`${ code } ${ message }`, err);\n// }\n\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake (socket: Socket, code: number, message?: string, headers?: any) {\n\tif (socket.writable) {\n\t\tmessage = message || STATUS_CODES[code];\n\t\theaders = Object.assign({\n\t\t\t'Connection': 'close',\n\t\t\t'Content-type': 'text/html',\n\t\t\t'Content-Length': Buffer.byteLength(message)\n\t\t}, headers);\n\n\t\tsocket.write(\n\t\t\t`HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n\t\t\tObject.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') +\n\t\t\t'\\r\\n\\r\\n' +\n\t\t\tmessage\n\t\t);\n\t}\n\n\tsocket.removeAllListeners('error');\n\tsocket.destroy();\n\n\tlogger.error(`${ code } ${ message }`);\n}\n\n\n\n// export function protocol<TClient extends Client<ISession>>(test: string) {\n// \treturn function<TServer extends Server<ISession, TClient, Gateway<ISession>>>(target: TServer) {\n//     // save a reference to the original constructor\n// \t\tconst original = target;\n\n// \t\t// a utility function to generate instances of a class\n// \t\tfunction construct(constructor: TServer, args: any) {\n// \t\t\tfunction c(): void {\n// \t\t\t\treturn (<any> constructor).apply(this, args);\n// \t\t\t}\n\n// \t\t\tc.prototype = (<any> constructor).prototype;\n\n// \t\t\treturn new (<any> c)();\n// \t\t}\n\n// \t\t// the new constructor behaviour\n// \t\tfunction f(...args: Array<any>) {\n// \t\t\tconsole.log(\"New: \" + (<any> original).name);\n// \t\t\treturn construct(original, args);\n// \t\t}\n\n// \t\t// copy prototype so intanceof operator still works\n// \t\tf.prototype = (<any> original).prototype;\n\n// \t\t// return new constructor (will override original)\n// \t\treturn f;\n// \t};\n// }\n\nexport abstract class AbstractServer<TSession extends ISession, TClient extends AbstractClient<TSession>, TGateway extends AbstractGateway<TSession>>\nextends WebSocket.Server {\n\n\t/**\n\t * Get session\n\t * @param {string} id\n\t */\n\tpublic static getSession<S extends AbstractSession<S, C, G>, C extends AbstractClient<S>, G extends AbstractGateway<S>>(id: string): S {\n\t\treturn <S> AbstractSession.get<S, C, G>(id);\n\t}\n\n\tprivate tokenizer: Tokenizer = null;\n\n\tpublic constructor(options: IWSServerOptions) {\n\t\tsuper(options);\n\n\t\tlet { signing } = options;\n\n\t\tif (signing)\n\t\t\tthis.tokenizer = new Tokenizer(signing);\n\n\t\tthis.on('connection', (socket: IWSSocket, request: IncomingMessage): void => {\n\t\t\tlet { protocol, tokenData } = socket;\n\n\t\t\tlet SessionType = this.getSessionClass(protocol);\n\t\t\tlet ClientType = this.getClientClass(protocol);\n\t\t\tlet GatewayType = this.getGatewayClass(protocol);\n\n\t\t\tlet session: TSession;\n\t\t\tlet client = new ClientType(socket, request);\n\n\t\t\tif (tokenData && tokenData.sessionID) {\n\t\t\t\tsession = <any> AbstractServer.getSession(tokenData.sessionID);\n\t\t\t}\n\n\t\t\tif (session) {\n\t\t\t\tlogger.debug(`Resuming existing session ${ session.ID }`);\n\n\t\t\t\tsession.client = client;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet gateway: TGateway;\n\n\t\t\t\tif (GatewayType)\n\t\t\t\t\tgateway = new GatewayType();\n\n\t\t\t\tsession = new SessionType(client, gateway);\n\n\t\t\t\tlogger.debug(`Creating new session ${ session.ID } with client${ gateway ? ' and gateway' : '' }`);\n\n\t\t\t\tsession\n\t\t\t\t\t// .on('registered', function () {\n\t\t\t\t\t// \t// add to B: dict\n\t\t\t\t\t// })\n\t\t\t\t\t.on('end', function (code: number, reason: string) {\n\t\t\t\t\t\t// remove from dictionary\n\t\t\t\t\t\t// session = null;\n\n\t\t\t\t\t\t// abortHandshake(socket, code, reason);\n\t\t\t\t\t\tclient.close();\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async handleUpgrade(request: IncomingMessage, socket: Socket, upgradeHead: Buffer, callback: (cws: WebSocket) => void) {\n\t\tlet clientSocket = await this.baseUpgrade(request, socket, upgradeHead);\n\n\t\tlet { url, headers } = request;\n\t\tlet { remoteAddress, localPort } = socket;\n\t\tlet ipv4 = process(remoteAddress).toString();\n\t\tlet channelHost = <string> headers.host;\n\n\t\tif (channelHost.indexOf(':') < 0)\n\t\t\tchannelHost += `:${ localPort }`;\n\n\t\tif (ipv4 === '::1')\n\t\t\tipv4 = '127.0.0.1';\n\n\t\tif (this.useTokens(clientSocket.protocol)) {\n\t\t\ttry {\n\t\t\t\tif (url.length > 20) {\n\t\t\t\t\tlet token = url.substr(1);\n\t\t\t\t\tlet tokenData = await this.tokenizer.unwrap(ipv4, channelHost, token);\n\n\t\t\t\t\tclientSocket.tokenData = tokenData;\n\t\t\t\t\tclientSocket.ipv4 = ipv4;\n\n\t\t\t\t\tcallback(clientSocket);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoTokenError();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tabortHandshake(socket, err.httpCode, err.message);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcallback(clientSocket);\n\t\t}\n\t}\n\n\tprotected useTokens(protocol: string): boolean {\n\t\treturn this.tokenizer !== null;\n\t}\n\n\tprotected abstract getSessionClass(protocol: string): { new(client: TClient, gateway: TGateway): TSession };\n\n\tprotected abstract getClientClass(protocol: string): { new(socket: IWSSocket, request: IncomingMessage): TClient };\n\n\tprotected abstract getGatewayClass(protocol: string): { new(): TGateway };\n\n\tprivate baseUpgrade(request: IncomingMessage, socket: Socket, upgradeHead: Buffer): Promise<any> {\n\t\treturn new Promise((resolve) => super.handleUpgrade(request, socket, upgradeHead, resolve));\n\t}\n}\n"]}