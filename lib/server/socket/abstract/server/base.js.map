{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../../src/server/socket/abstract/server/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'http';\nimport * as WebSocket from 'ws';\nimport { process } from 'ipaddr.js';\nimport { Writeln } from 'writeln';\nimport { IWSServerOptions, IWSSocket, ISession, IIncomingMessage } from '../../contracts';\nimport { Tokenizer, NoTokenError } from '../../../tokenizer';\nimport { AbstractClient } from '../client';\nimport { AbstractGateway } from '../gateway';\nimport { AbstractSession } from '../session';\n\nconst logger = new Writeln('WS WebSocket Server');\n\ninterface IVerifyClientInfo {\n\torigin: string;\n\tsecure: boolean;\n\treq: IncomingMessage\n}\n\ntype VerifyClientCallback = (res: boolean, code?: number, message?: string) => void;\n\nexport abstract class AbstractServer<TSession extends ISession, TClient extends AbstractClient<TSession>, TGateway extends AbstractGateway<TSession>> {\n\n\t/**\n\t * Get session\n\t * @param {string} id\n\t */\n\tpublic static getSession<S extends AbstractSession<S, C, G>, C extends AbstractClient<S>, G extends AbstractGateway<S>>(id: string): S {\n\t\treturn <S> AbstractSession.get<S, C, G>(id);\n\t}\n\n\treadonly tokenizer: Tokenizer = null;\n\n\tpublic constructor(options: IWSServerOptions) {\n\t\tthis.createServer(options);\n\n\t\tconst { signing } = options;\n\n\t\tif (signing)\n\t\t\tthis.tokenizer = new Tokenizer(signing);\n\t}\n\n\tprotected useTokens(protocol: string): boolean {\n\t\treturn this.tokenizer !== null;\n\t}\n\n\tprotected abstract getSessionClass(protocol: string): { new(client: TClient, gateway: TGateway): TSession };\n\n\tprotected abstract getClientClass(protocol: string): { new(socket: IWSSocket, request: IncomingMessage): TClient };\n\n\tprotected abstract getGatewayClass(protocol: string): { new(): TGateway };\n\n\tprotected onConnected(socket: IWSSocket, request: IIncomingMessage) {\n\t\tconst { protocol } = socket;\n\t\tconst { tokenData } = request;\n\n\t\tconst SessionType = this.getSessionClass(protocol);\n\t\tconst ClientType = this.getClientClass(protocol);\n\t\tconst GatewayType = this.getGatewayClass(protocol);\n\n\t\tlet session: TSession;\n\t\tconst client = new ClientType(socket, request);\n\n\t\tif (tokenData && tokenData.sessionID) {\n\t\t\tsession = <any> AbstractServer.getSession(tokenData.sessionID);\n\t\t}\n\n\t\tif (session) {\n\t\t\tlogger.debug(`Resuming existing session ${ session.ID }`);\n\n\t\t\tsession.client = client;\n\t\t}\n\t\telse {\n\t\t\tlet gateway: TGateway;\n\n\t\t\tif (GatewayType)\n\t\t\t\tgateway = new GatewayType();\n\n\t\t\tsession = new SessionType(client, gateway);\n\n\t\t\tlogger.debug(`Creating new session ${ session.ID } with client${ gateway ? ' and gateway' : '' }`);\n\n\t\t\tsession\n\t\t\t// .on('registered', function () {\n\t\t\t// \t// add to B: dict\n\t\t\t// })\n\t\t\t\t.on('end', function (code: number, reason: string) {\n\t\t\t\t\t// remove from dictionary\n\t\t\t\t\t// session = null;\n\n\t\t\t\t\t// abortHandshake(socket, code, reason);\n\t\t\t\t\tclient.close();\n\t\t\t\t});\n\t\t}\n\t}\n\n\tprivate createServer(options: WebSocket.ServerOptions) {\n\t\tconst wsServer = new WebSocket.Server(Object.assign(options, { verifyClient: options.verifyClient || this.verifyClient.bind(this) }));\n\n\t\twsServer.on('connection', (socket: IWSSocket, request: IIncomingMessage) => this.onConnected(socket, request));\n\t}\n\n\tprivate async verifyClient(info: IVerifyClientInfo, callback: VerifyClientCallback) {\n\t\tconst req = info.req as IIncomingMessage;\n\t\tconst { url, headers, socket: { remoteAddress, localPort } } = req;\n\n\t\tlet ipv4 = process(remoteAddress).toString();\n\t\tlet channelHost = <string> headers.host;\n\n\t\tif (channelHost.indexOf(':') < 0)\n\t\t\tchannelHost += `:${ localPort }`;\n\n\t\tif (ipv4 === '::1')\n\t\t\tipv4 = '127.0.0.1';\n\n\t\tif (this.useTokens(headers['sec-websocket-protocol'] as string)) {\n\t\t\t// try {\n\t\t\tif (url.length > 20) {\n\t\t\t\tconst token = url.substr(1);\n\n\t\t\t\treq.tokenData = await this.tokenizer.unwrap(ipv4, channelHost, token);\n\t\t\t\treq.ipv4 = ipv4;\n\n\t\t\t\tcallback(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoTokenError();\n\t\t\t}\n\t\t\t// }\n\t\t\t// catch (err) {\n\t\t\t// \tcallback(false, err.httpCode, err.message);\n\t\t\t// }\n\t\t}\n\t\telse {\n\t\t\tcallback(true);\n\t\t}\n\t}\n}\n"]}