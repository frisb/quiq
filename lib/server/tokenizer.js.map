{"version":3,"file":"tokenizer.js","sourceRoot":"","sources":["../../src/server/tokenizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpError } from 'routing-controllers';\nimport { sign, verify, JsonWebTokenError } from 'jsonwebtoken';\nimport { Writeln } from 'writeln';\nimport { ISigningOptions } from './contracts';\nimport { IWrappedToken } from '../common/';\n\nconst logger = new Writeln('Tokenizer');\n\nexport class IpAddressError extends HttpError {\n\tconstructor() {\n\t\tsuper(401, 'Unauthorized');\n\t}\n}\n\nexport class HostError extends HttpError {\n\tconstructor() {\n\t\tsuper(401, 'Unauthorized');\n\t}\n}\n\nexport class NoTokenError extends HttpError {\n\tconstructor() {\n\t\tsuper(403, 'Forbidden');\n\t}\n}\n\nexport class TokenInvalidError extends HttpError {\n\tconstructor(err: Error) {\n\t\tsuper(498, 'Token expired/invalid');\n\n\t\tlogger.error(err.message, err);\n\t}\n}\n\nexport class Tokenizer {\n\tconstructor(public signing: ISigningOptions) {}\n\n\tpublic wrap(remoteIP: string, channelOrigin: string, data: any, include?: string[]): IWrappedToken {\n\t\tlet { expirySeconds, secret, algorithm } = this.signing;\n\t\tlet options = { expiresIn: expirySeconds, algorithm };\n\n\t\tdata.ip = remoteIP;\n\t\tdata.origin = channelOrigin;\n\n\t\tlet accessToken = sign(data, secret, options);\n\n\t\tlet wrappedToken: IWrappedToken = {\n\t\t\taccess_token: accessToken,\n\t\t\ttoken_type: 'bearer',\n\t\t\texpires_in: expirySeconds\n\t\t};\n\n\t\tif (include) {\n\t\t\tfor (let i = 0, { length } = include; i < length; i++) {\n\t\t\t\tlet key = include[i];\n\t\t\t\tlet val = data[key];\n\n\t\t\t\tif (val)\n\t\t\t\t\twrappedToken[key] = val;\n\t\t\t}\n\t\t}\n\n\t\treturn wrappedToken;\n\t}\n\n\tpublic async unwrap(remoteIP: string, channelOrigin: string, token: string): Promise<{}> {\n\t\tlet { algorithm, secret } = this.signing;\n\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tlet algorithms = [algorithm];\n\t\t\tlet options = { algorithms };\n\n\t\t\tverify(token, secret, options, function (err: JsonWebTokenError, data: any) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(new TokenInvalidError(err));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet { ip, origin } = data;\n\n\t\t\t\t\tif (ip !== remoteIP) {\n\t\t\t\t\t\treject(new IpAddressError());\n\t\t\t\t\t}\n\t\t\t\t\telse if (origin !== channelOrigin) {\n\t\t\t\t\t\treject(new HostError());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet tokenData: any = {};\n\n\t\t\t\t\t\tfor (let key in data) {\n\t\t\t\t\t\t\tif (key !== 'iat' && key !== 'exp' && key !== 'ip')\n\t\t\t\t\t\t\t\ttokenData[key] = data[key];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve(tokenData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n"]}